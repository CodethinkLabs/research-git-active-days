#!/usr/bin/env python
# Copyright (C) 2015  Codethink Limited
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program.  If not, see <http://www.gnu.org/licenses/>.

'''Calculate Git Active Days for one or more Git repositories.

The idea of the 'Git Active Days' metric was taken from the `git-summary` and
`git-effort` programs in <https://github.com/tj/git-extras>.

'''

import argparse
import fnmatch
import os
import subprocess
import sys


def active_days(repo, refs):
    '''Returns the set of days where 'repo' had at least one commit.'''
    # List the author date for each commit.
    text = git_output(['git', 'log' , '--pretty=format:%ai'] + refs, cwd=repo)

    # Store all dates in a set, which will merge any duplicates.
    days = set()
    for line in text.splitlines():
        if len(line) == 0:
            # A date of 1970-01-01 indicates the commit is corrupt somehow, and
            # is represented as a blank line in the output. Ignore these.
            # See also: http://thread.gmane.org/gmane.comp.version-control.git/250354/focus=250392
            continue
        else:
            date, time, timezone = line.split()
        days.add(date)
    return days


def active_person_days(repo, refs):
    '''Return the list of active days in 'repo' for each commit author.

    For example, if Fred made four commits on Monday, and Suzie committed once
    on Monday and Tuesday, you will get 3 results: Fred was active Monday,
    and Suzie was active Monday and Tuesday.

    The size of this set gives you an 'active person-days' metric.

    '''
    # List author email and author date for each commit.
    # In theory, any character could appear in the email address
    # so we should use \0 as a separator, or something.
    # See: https://tools.ietf.org/html/rfc3696#section-3
    text = git_output(['git', 'log' , '--pretty=format:%ae:%ai'] + refs, cwd=repo)

    # Store all (email, date) pairs in a set, which will merge any duplicates.
    author_days = set()
    for line in text.splitlines():
        author_email, datetime = line.split(':', 1)
        if len(datetime) == 0:
            continue
        else:
            date, time, timezone = datetime.split()
        author_days.add((author_email, date))
    return author_days


def git_output(args, cwd=None):
    try:
        text = subprocess.check_output(args, cwd=cwd, stderr=subprocess.STDOUT)
    except subprocess.CalledProcessError as e:
        raise RuntimeError("Git command failed, with output:\n%s" % e.output)
    return text.decode('unicode-escape')


def check_refs_exist(repo, refs):
    missing = []
    for ref in refs:
        if ref != '--all':
            with open(os.devnull, 'w') as f:
                result = subprocess.call(
                    ['git', 'rev-parse', '--verify', ref], stderr=f, stdout=f)
            if result != 0:
                missing.append(ref)
    if len(missing) > 0:
        raise RuntimeError(
            "Did not find refs %s in repo %s" % (', '.join(refs), repo))


def filter_person_days(person_days_set, author_email_glob):
    result = set()
    for item in person_days_set:
        if fnmatch.fnmatch(item[0], author_email_glob):
            result.add(item)
    if len(result) == 0 and '*' not in author_email_glob:
        sys.stderr.write(
            "Glob '%s' didn't match any email addresses. Perhaps '*%s*' "
            "would?\n" % (author_email_glob, author_email_glob))
    return result


def argument_parser():
    parser = argparse.ArgumentParser(
        description="Counts days where commits were made, across one or more "
                    "Git repositories.")

    parser.add_argument(
        '--filter-author-email', metavar='PATTERN', type=str,
        help="only count commits where the author's email matches a glob "
             "pattern")

    # It might be clearer to have the inverse of this option instead
    # (--combine-authors), but it's nice to have the default behaviour be
    # the same as that of `git-summary` and `git-effort`.
    parser.add_argument(
        '--person-days', action='store_true',
        help="count commits per author on each day, not just number of days")

    # This works by injecting the '--all' commandline option into the list of
    # refs, which we pass straight through to `git log`.
    parser.add_argument(
        '--all-refs', action='store_const', dest='refs', const=['--all'],
        help="measure all commits in all Git refs")

    parser.add_argument(
        '--ref', metavar='REF', action='append', dest='refs',
        help="a Git ref pattern to measure. Default is to measure HEAD.")

    parser.add_argument(
        'repos', metavar='<repo>', type=str, nargs='*',
        help="Path to one or more Git repos. Where there are multiple repos, "
             "an 'active day' is one where there was a commit in any of those "
             "repos. If no paths are given, the current directory is used.")

    return parser


def main():
    args = argument_parser().parse_args()

    if len(args.repos) == 0:
        args.repos = ['.']

    if args.refs is None:
        args.refs = ['HEAD']
    else:
        for repo in args.repos:
            check_refs_exist(repo, args.refs)

    if args.filter_author_email and not args.person_days:
        raise RuntimeError("The --filter-author-email option cannot be used "
                           "without --person-days.")

    result = None

    if args.person_days:
        all_person_days = set()
        for repo in args.repos:
            person_days = active_person_days(repo, refs=args.refs)
            all_person_days.update(person_days)

        if args.filter_author_email:
            all_person_days = filter_person_days(
                all_person_days, args.filter_author_email)

        result = len(all_person_days)
    else:
        all_days = set()
        for repo in args.repos:
            days = active_days(repo, refs=args.refs)
            all_days.update(days)

        result = len(all_days)

    print(result)


try:
    main()
except RuntimeError as e:
    sys.stderr.write('ERROR: %s\n' % e)
    sys.exit(1)
